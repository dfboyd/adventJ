if `r` is a userdefined function, then `r/ i. 4`
is
```
0 r 1 r 2 r 3
```

which is evaluated as

```
(0 r (1 r (2 r 3)))
```
Since we want to work the data left to right, the easiest thing to do
is reverse the list before reducing with `r`.

The result of `2 r 3` should be `5 6`: `2+3, 2*3`.

# part 2

Given the original list of numbers, we want to get a set of all
possible lists generated by applying the concatenation operator.

For example: `1 2 3` should generate:

```
1 2 3 ; 12 3 ; 1 23 ; 123
```

i.e. a list of boxed lists.

I think we can do this recursively.  At each level, you either do, or
do not, concatenate the first two elements.  Then you recurse on that.

Can you nub-sieve a list of boxes lists?  Yes you can.

Recursion: input is a list, return list of boxed lists
  base case: one element list (it comes in a box)
  just return it (boxed)

  recursive case:
    say input is 1 2 3 4
	recurse 12 3 4
	  result A: (list of boxes)
	recurse 2 3 4
	  result B: list of boxes
	  C = prepend '1' to all elements of B
   return A, C

that's nconcat

nconcat takes a list, and returns a list of boxed lists.

f used to take a single list, take its head, and check against the
rest.

Now f2 needs to take a single list, take its head, 
and compare against each of (nconcat tail)

# error

It turns out it's not supposed to work the way I thought it did.

```
7290: 6 8 6 15
```
is solved like this:

```
6 * 8 || 6 * 15
48 || 6 * 15
486 * 15
7290
```

So the `r/` has to be rewritten to work on a list of elements as it
right argument.  I.e. I want this `r`:

```
r =: 4 : 0
  (x + y) , (x * y), x ncatl y
)
```

```
   2 ncatl 2 3 4
22 23 24
```